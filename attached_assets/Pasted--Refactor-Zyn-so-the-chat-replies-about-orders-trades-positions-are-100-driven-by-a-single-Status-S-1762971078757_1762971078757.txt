“Refactor Zyn so the chat replies about orders/trades/positions are 100% driven by a single Status Service, never by LLM memory. Implement a status-service module with functions: get_mode() (returns paper or live), get_balances(), get_open_orders(), get_closed_orders(since, until), get_trades(since, until, limit, cursor), and get_activity_summary(window=24h|7d|30d). Wire it to Kraken’s private endpoints with proper pagination and time windows; do not default to 1 page—iterate until the cursor/offset is exhausted. Normalize all timestamps to UTC internally; convert to local only for UI. Add a small persistence layer (SQLite or Postgres) with tables trades, orders, balances, sync_state; create an idempotent sync_exchange() that pulls from Kraken (both paper and live depending on current mode), upserts by unique IDs, and records last_synced_at. Introduce a strict mode switch: env var TRADE_MODE = paper or live; expose a single toggle in the UI that updates this value and triggers a full resync; block any live order placement when in paper mode. Paper trading must use a local simulator that writes to the same schema as live (so the Status Service is blind to the source). All chat answers must call status-service.get_activity_summary(); if the data is older than 60 seconds, the function must first call sync_exchange(). In get_activity_summary(), compute counts and PnL for the last 24h, 7d, and 30d using DB rows, not cached prompts; include totals of buys, sells, average entry/exit prices, realized PnL, and current holdings. Add a healthcheck that verifies: API keys present and scopes valid, last sync < 60s (warning if 60–300s, error if > 300s), DB reachable, and mode alignment (chat UI mode == backend env mode). Create a status HTTP endpoint (and SDK function) that returns JSON: {mode, lastSyncUTC, totals:{24h,7d,30d}, openOrders, recentTrades, balances, warnings}; make the chat layer depend exclusively on this endpoint/SDK for status answers. Add structured logging (JSON) with a trace_id threaded from chat → status → exchange calls. Handle rate limits with exponential backoff and jitter; set max retry=3 and total timeout=5s per call. Add tests: unit (pagination, UTC windowing, idempotent upsert), integration (mock Kraken API then simulate 5 trades and ensure get_activity_summary() returns exact counts and PnL), and e2e (toggle paper↔live, place 2 paper trades, verify chat answer shows 2 trades in 24h; switch to live mock, add 3 more, answer shows 5 in 24h). Add a reconciliation command zyn reconcile --since 30d: diff local DB vs Kraken, repair missing rows, and emit a discrepancy report. Update the dashboard to read from the same status endpoint so UI and chat always match. Guardrails for the LLM: for any status question, call status-service; if the service returns an error or stale data, reply with ‘Unknown’ + the healthcheck warnings—never hallucinate. Deliverables: (a) status-service module + tests, (b) exchange client with pagination + UTC normalization, (c) DB schema + migrations, (d) mode toggle wired to TRADE_MODE with full resync, (e) reconciliation tool, (f) updated chat intent that calls status.getActivitySummary instead of reading prior messages, (g) dashboard wired to the same endpoint. Definition of done: placing 3 paper trades within the last hour produces 3 for 24h in both chat and dashboard; switching to live with 0 trades shows 0; changing time windows yields correct counts; no status answer is produced without a fresh or validated sync; logs are visible and include trace IDs.”